/*
 * This file is part of JavaSMT,
 * an API wrapper for a collection of SMT solvers:
 * https://github.com/sosy-lab/java-smt
 *
 * SPDX-FileCopyrightText: 2024 Dirk Beyer <https://www.sosy-lab.org>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package org.sosy_lab.java_smt.solvers.z3;

import com.microsoft.z3.Native;
import com.microsoft.z3.enumerations.Z3_decl_kind;
import com.microsoft.z3.enumerations.Z3_sort_kind;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.Map;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.proofs.ProofRule;

/**
 * This class is used to process the proof generated by Z3 and store it as a ProofNode. It is a
 * non-(java-)recursive implementation of the proof processor.#
 *
 * <p>The resulting DAG from transforming the proof from the Z3 provided structures into a set of
 * {@link Z3ProofDag.Z3ProofNode} should enable an easier way to extract the information from the
 * proofs. However, some information is lost from the original proof, as the Z3 provided proof makes
 * uses of more general structures like AST, SortKind, DeclKind. E.g. the leafs in the {@link
 * Z3ProofDag.Z3ProofNode} contain the whole formula used for the first proof rules in the tree,
 * while these are internal nodes in the Z3 proof and leafs are the operands use in innermost terms.
 */
@SuppressWarnings({"unchecked", "rawtypes", "unused", "static-access"})
class Z3NonRecursiveProofProcessor {
  private final long z3context;
  private final long z3solver;
  private final Z3FormulaCreator formulaCreator;
  private final Z3AbstractProver prover;

  Z3NonRecursiveProofProcessor(
      long ctx, long solver, Z3FormulaCreator creator, Z3AbstractProver pProver) {
    z3context = ctx;
    z3solver = solver;
    formulaCreator = creator;
    prover = pProver;
  }

  Z3ProofDag.Z3ProofNode fromASTIterative(long rootProof) {
    // proof ast to be processed wrapped inside a frame
    Deque<Frame> stack = new ArrayDeque<>();

    // proof ast has been converted into ProofNode
    Map<Long, Z3ProofDag.Z3ProofNode> computed = new HashMap<>();

    stack.push(new Frame(rootProof));

    while (!stack.isEmpty()) {
      Frame frame = stack.peek();

      // prevent processing the same proof ast multiple times
      if (!frame.visited) {

        Native.incRef(z3context, frame.proof);

        // The number of children of the proof node
        frame.numArgs = Native.getAppNumArgs(z3context, frame.proof);
        frame.visited = true;

        for (int i = frame.numArgs - 2; i >= 0; i--) {
          long arg = Native.getAppArg(z3context, frame.proof, i);

          if (!computed.containsKey(arg)) {
            stack.push(new Frame(arg));
          }
        }
      } else {

        stack.pop();
        int numArgs = frame.numArgs;
        Formula formula;

        // needed for the sortKind
        long sort = Native.getSort(z3context, frame.proof);
        long sortKind = Native.getSortKind(z3context, sort);
        Z3_sort_kind sk = Z3_sort_kind.fromInt((int) sortKind);
        if (sk != Z3_sort_kind.Z3_UNKNOWN_SORT) {
          // This should be a proof sort, this is not included in the enum class provided by the API
          formula = generateFormula(frame.proof);
        } else {
          // Return the i-th argument of the given application. The formula resulting from
          // applying the proof rule is the last argument of the proof node.
          long z3expr = Native.getAppArg(z3context, frame.proof, numArgs - 1);
          formula = generateFormula(z3expr);
        }
        int declKind = Native.getDeclKind(z3context, Native.getAppDecl(z3context, frame.proof));
        ProofRule proofRule = getPRfromDK(declKind);
        Z3ProofDag.Z3ProofNode node = new Z3ProofDag.Z3ProofNode(formula, proofRule);

        for (int i = 0; i < numArgs - 1; i++) {
          long arg = Native.getAppArg(z3context, frame.proof, i);
          if (computed.containsKey(arg)) {
            node.addChild(computed.get(arg));
          }
        }
        computed.put(frame.proof, node);
        Native.decRef(z3context, frame.proof);
      }
    }
    return computed.get(rootProof);
  }

  private ProofRule getPRfromDK(int declKind) {
    String rawName = Z3_decl_kind.fromInt(declKind).name();
    String prName = rawName.replaceFirst("Z3_OP_PR_", "");
    // return ProofRule.fromName(Z3ProofRule.class, prName);
    return Enum.valueOf(Z3ProofRule.class, prName);
  }

  private Formula generateFormula(long proof) {
    Formula formula = null;
    if (formula == null) {
      formula = formulaCreator.encapsulate(formulaCreator.getFormulaType(proof), proof);
    }
    return formula;
  }

  private static class Frame {
    final long proof;
    int numArgs;
    boolean visited;

    Frame(long proof) {
      this.proof = proof;
      this.visited = false;
    }
  }
}
