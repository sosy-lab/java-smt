// This file is part of JavaSMT,
// an API wrapper for a collection of SMT solvers:
// https://github.com/sosy-lab/java-smt
//
// SPDX-FileCopyrightText: 2024 Dirk Beyer <https://www.sosy-lab.org>
//
// SPDX-License-Identifier: Apache-2.0

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.sosy_lab.java_smt.solvers.bitwuzla.api;

public final class Kind {
  public final static Kind CONSTANT = new Kind("CONSTANT", BitwuzlaNativeJNI.Kind_CONSTANT_get());
  public final static Kind CONST_ARRAY = new Kind("CONST_ARRAY");
  public final static Kind VALUE = new Kind("VALUE");
  public final static Kind VARIABLE = new Kind("VARIABLE");
  public final static Kind AND = new Kind("AND");
  public final static Kind DISTINCT = new Kind("DISTINCT");
  public final static Kind EQUAL = new Kind("EQUAL");
  public final static Kind IFF = new Kind("IFF");
  public final static Kind IMPLIES = new Kind("IMPLIES");
  public final static Kind NOT = new Kind("NOT");
  public final static Kind OR = new Kind("OR");
  public final static Kind XOR = new Kind("XOR");
  public final static Kind ITE = new Kind("ITE");
  public final static Kind EXISTS = new Kind("EXISTS");
  public final static Kind FORALL = new Kind("FORALL");
  public final static Kind APPLY = new Kind("APPLY");
  public final static Kind LAMBDA = new Kind("LAMBDA");
  public final static Kind ARRAY_SELECT = new Kind("ARRAY_SELECT");
  public final static Kind ARRAY_STORE = new Kind("ARRAY_STORE");
  public final static Kind BV_ADD = new Kind("BV_ADD");
  public final static Kind BV_AND = new Kind("BV_AND");
  public final static Kind BV_ASHR = new Kind("BV_ASHR");
  public final static Kind BV_COMP = new Kind("BV_COMP");
  public final static Kind BV_CONCAT = new Kind("BV_CONCAT");
  public final static Kind BV_DEC = new Kind("BV_DEC");
  public final static Kind BV_INC = new Kind("BV_INC");
  public final static Kind BV_MUL = new Kind("BV_MUL");
  public final static Kind BV_NAND = new Kind("BV_NAND");
  public final static Kind BV_NEG = new Kind("BV_NEG");
  public final static Kind BV_NEG_OVERFLOW = new Kind("BV_NEG_OVERFLOW");
  public final static Kind BV_NOR = new Kind("BV_NOR");
  public final static Kind BV_NOT = new Kind("BV_NOT");
  public final static Kind BV_OR = new Kind("BV_OR");
  public final static Kind BV_REDAND = new Kind("BV_REDAND");
  public final static Kind BV_REDOR = new Kind("BV_REDOR");
  public final static Kind BV_REDXOR = new Kind("BV_REDXOR");
  public final static Kind BV_ROL = new Kind("BV_ROL");
  public final static Kind BV_ROR = new Kind("BV_ROR");
  public final static Kind BV_SADD_OVERFLOW = new Kind("BV_SADD_OVERFLOW");
  public final static Kind BV_SDIV_OVERFLOW = new Kind("BV_SDIV_OVERFLOW");
  public final static Kind BV_SDIV = new Kind("BV_SDIV");
  public final static Kind BV_SGE = new Kind("BV_SGE");
  public final static Kind BV_SGT = new Kind("BV_SGT");
  public final static Kind BV_SHL = new Kind("BV_SHL");
  public final static Kind BV_SHR = new Kind("BV_SHR");
  public final static Kind BV_SLE = new Kind("BV_SLE");
  public final static Kind BV_SLT = new Kind("BV_SLT");
  public final static Kind BV_SMOD = new Kind("BV_SMOD");
  public final static Kind BV_SMUL_OVERFLOW = new Kind("BV_SMUL_OVERFLOW");
  public final static Kind BV_SREM = new Kind("BV_SREM");
  public final static Kind BV_SSUB_OVERFLOW = new Kind("BV_SSUB_OVERFLOW");
  public final static Kind BV_SUB = new Kind("BV_SUB");
  public final static Kind BV_UADD_OVERFLOW = new Kind("BV_UADD_OVERFLOW");
  public final static Kind BV_UDIV = new Kind("BV_UDIV");
  public final static Kind BV_UGE = new Kind("BV_UGE");
  public final static Kind BV_UGT = new Kind("BV_UGT");
  public final static Kind BV_ULE = new Kind("BV_ULE");
  public final static Kind BV_ULT = new Kind("BV_ULT");
  public final static Kind BV_UMUL_OVERFLOW = new Kind("BV_UMUL_OVERFLOW");
  public final static Kind BV_UREM = new Kind("BV_UREM");
  public final static Kind BV_USUB_OVERFLOW = new Kind("BV_USUB_OVERFLOW");
  public final static Kind BV_XNOR = new Kind("BV_XNOR");
  public final static Kind BV_XOR = new Kind("BV_XOR");
  public final static Kind BV_EXTRACT = new Kind("BV_EXTRACT");
  public final static Kind BV_REPEAT = new Kind("BV_REPEAT");
  public final static Kind BV_ROLI = new Kind("BV_ROLI");
  public final static Kind BV_RORI = new Kind("BV_RORI");
  public final static Kind BV_SIGN_EXTEND = new Kind("BV_SIGN_EXTEND");
  public final static Kind BV_ZERO_EXTEND = new Kind("BV_ZERO_EXTEND");
  public final static Kind FP_ABS = new Kind("FP_ABS");
  public final static Kind FP_ADD = new Kind("FP_ADD");
  public final static Kind FP_DIV = new Kind("FP_DIV");
  public final static Kind FP_EQUAL = new Kind("FP_EQUAL");
  public final static Kind FP_FMA = new Kind("FP_FMA");
  public final static Kind FP_FP = new Kind("FP_FP");
  public final static Kind FP_GEQ = new Kind("FP_GEQ");
  public final static Kind FP_GT = new Kind("FP_GT");
  public final static Kind FP_IS_INF = new Kind("FP_IS_INF");
  public final static Kind FP_IS_NAN = new Kind("FP_IS_NAN");
  public final static Kind FP_IS_NEG = new Kind("FP_IS_NEG");
  public final static Kind FP_IS_NORMAL = new Kind("FP_IS_NORMAL");
  public final static Kind FP_IS_POS = new Kind("FP_IS_POS");
  public final static Kind FP_IS_SUBNORMAL = new Kind("FP_IS_SUBNORMAL");
  public final static Kind FP_IS_ZERO = new Kind("FP_IS_ZERO");
  public final static Kind FP_LEQ = new Kind("FP_LEQ");
  public final static Kind FP_LT = new Kind("FP_LT");
  public final static Kind FP_MAX = new Kind("FP_MAX");
  public final static Kind FP_MIN = new Kind("FP_MIN");
  public final static Kind FP_MUL = new Kind("FP_MUL");
  public final static Kind FP_NEG = new Kind("FP_NEG");
  public final static Kind FP_REM = new Kind("FP_REM");
  public final static Kind FP_RTI = new Kind("FP_RTI");
  public final static Kind FP_SQRT = new Kind("FP_SQRT");
  public final static Kind FP_SUB = new Kind("FP_SUB");
  public final static Kind FP_TO_FP_FROM_BV = new Kind("FP_TO_FP_FROM_BV");
  public final static Kind FP_TO_FP_FROM_FP = new Kind("FP_TO_FP_FROM_FP");
  public final static Kind FP_TO_FP_FROM_SBV = new Kind("FP_TO_FP_FROM_SBV");
  public final static Kind FP_TO_FP_FROM_UBV = new Kind("FP_TO_FP_FROM_UBV");
  public final static Kind FP_TO_SBV = new Kind("FP_TO_SBV");
  public final static Kind FP_TO_UBV = new Kind("FP_TO_UBV");
  public final static Kind NUM_KINDS = new Kind("NUM_KINDS");

  public final int swigValue() {
    return swigValue;
  }

  public String toString() {
    return swigName;
  }

  public static Kind swigToEnum(int swigValue) {
    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
      return swigValues[swigValue];
    for (int i = 0; i < swigValues.length; i++)
      if (swigValues[i].swigValue == swigValue)
        return swigValues[i];
    throw new IllegalArgumentException("No enum " + Kind.class + " with value " + swigValue);
  }

  private Kind(String swigName) {
    this.swigName = swigName;
    this.swigValue = swigNext++;
  }

  private Kind(String swigName, int swigValue) {
    this.swigName = swigName;
    this.swigValue = swigValue;
    swigNext = swigValue+1;
  }

  private Kind(String swigName, Kind swigEnum) {
    this.swigName = swigName;
    this.swigValue = swigEnum.swigValue;
    swigNext = this.swigValue+1;
  }

  private static Kind[] swigValues = { CONSTANT, CONST_ARRAY, VALUE, VARIABLE, AND, DISTINCT, EQUAL, IFF, IMPLIES, NOT, OR, XOR, ITE, EXISTS, FORALL, APPLY, LAMBDA, ARRAY_SELECT, ARRAY_STORE, BV_ADD, BV_AND, BV_ASHR, BV_COMP, BV_CONCAT, BV_DEC, BV_INC, BV_MUL, BV_NAND, BV_NEG, BV_NEG_OVERFLOW, BV_NOR, BV_NOT, BV_OR, BV_REDAND, BV_REDOR, BV_REDXOR, BV_ROL, BV_ROR, BV_SADD_OVERFLOW, BV_SDIV_OVERFLOW, BV_SDIV, BV_SGE, BV_SGT, BV_SHL, BV_SHR, BV_SLE, BV_SLT, BV_SMOD, BV_SMUL_OVERFLOW, BV_SREM, BV_SSUB_OVERFLOW, BV_SUB, BV_UADD_OVERFLOW, BV_UDIV, BV_UGE, BV_UGT, BV_ULE, BV_ULT, BV_UMUL_OVERFLOW, BV_UREM, BV_USUB_OVERFLOW, BV_XNOR, BV_XOR, BV_EXTRACT, BV_REPEAT, BV_ROLI, BV_RORI, BV_SIGN_EXTEND, BV_ZERO_EXTEND, FP_ABS, FP_ADD, FP_DIV, FP_EQUAL, FP_FMA, FP_FP, FP_GEQ, FP_GT, FP_IS_INF, FP_IS_NAN, FP_IS_NEG, FP_IS_NORMAL, FP_IS_POS, FP_IS_SUBNORMAL, FP_IS_ZERO, FP_LEQ, FP_LT, FP_MAX, FP_MIN, FP_MUL, FP_NEG, FP_REM, FP_RTI, FP_SQRT, FP_SUB, FP_TO_FP_FROM_BV, FP_TO_FP_FROM_FP, FP_TO_FP_FROM_SBV, FP_TO_FP_FROM_UBV, FP_TO_SBV, FP_TO_UBV, NUM_KINDS };
  private static int swigNext = 0;
  private final int swigValue;
  private final String swigName;
}

